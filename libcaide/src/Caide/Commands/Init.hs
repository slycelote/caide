{-# LANGUAGE CPP, OverloadedStrings, NamedFieldPuns, ScopedTypeVariables #-}
#ifdef CLANG_INLINER
{-# LANGUAGE TemplateHaskell #-}
#endif

module Caide.Commands.Init(
      initialize
) where

import Control.Exception (try, IOException)
import Control.Monad (forM_)
import Control.Monad.State (execStateT)
import Codec.Archive.Zip (extractFilesFromArchive, toArchive, ZipOption(..))
import qualified Data.ByteString as BS
import Data.ByteString.Lazy (fromStrict)
import Data.Char (isSpace)
import Data.List (dropWhileEnd, isInfixOf, isPrefixOf)
import Data.Function ((&))
import Data.Maybe (fromMaybe)
import Data.FileEmbed (embedFile)
import qualified Data.Text as T
import qualified Data.Text.IO.Util as T
import System.Environment (lookupEnv)
import System.Info (arch, os)
import System.Process (readProcessWithExitCode)

import qualified Filesystem as FS
import qualified Filesystem.Path.CurrentOS as FS
import Filesystem.Path.CurrentOS (encodeString, (</>))
import Filesystem.Util (pathToText, writeTextFile)

import qualified Data.ConfigFile as CF

import Caide.Configuration (writeConfigFile, putProp)
import qualified Caide.Paths as Paths
import Caide.Templates (templates)
import Paths_CaideExt (resourcesZipFilePath) -- autogenerated by Setup.hs


getSystemCompilerInfo :: IO SystemCompilerInfo
getSystemCompilerInfo = do
    [vs12, vs14, vs15] <- mapM lookupEnv ["VS120COMNTOOLS", "VS140COMNTOOLS", "VS150COMNTOOLS"]
    let mscver = case (vs12, vs14, vs15) of
            (_, _, Just _) -> 1900
            (_, Just _, _) -> 1900
            (Just _, _, _) -> 1800
            _              -> 1700
    gcc <- fromMaybe "g++" <$> lookupEnv "CXX"
    -- TODO: More robust subprocess handling (e.g. timeout)
    -- TODO: Set locale
    processResult <- try $ readProcessWithExitCode gcc ["-x", "c++", "-E" ,"-v", "-"] ""
    let gccIncludeDirectories = case processResult of
            Left  (_ex :: IOException)         -> []
            Right (_exitCode, _stdOut, stdErr) -> parseGccOutput stdErr
    return $ SystemCompilerInfo { mscver, gccIncludeDirectories }

parseGccOutput :: String -> [String]
parseGccOutput output = map trim $ filter isDirectory $ takeWhile (not . endOfSearchListLine) $ dropWhile (not . searchStartsHereLine) $ lines output
  where
    trim = dropWhileEnd isSpace . dropWhile isSpace
    isDirectory s = take 1 s == " "
    endOfSearchListLine s = "End of search list." `isInfixOf` s
    searchStartsHereLine s = "search starts here:" `isInfixOf` s


initialize :: FS.FilePath -> Bool -> IO ()
initialize curDir useSystemCppHeaders = do
    compiler <- getSystemCompilerInfo
    writeConfigFile (defaultCaideConf curDir useSystemCppHeaders compiler) $
        curDir </> Paths.caideConfFile
    writeConfigFile defaultCaideState $ curDir </> Paths.caideStateFile
#ifdef CLANG_INLINER
    unpackResources curDir
#endif
    FS.createTree $ curDir </> "templates"
    FS.createTree $ curDir </> ".caide" </> "templates"
    forM_ templates $ \(fileName, cont) -> do
        writeTextFile (curDir </> "templates" </> fileName) cont
        writeTextFile (curDir </> ".caide" </> "templates" </> fileName) cont
    T.putStrLn . T.concat $ ["Initialized caide directory at ", pathToText curDir]

data SystemCompilerInfo = SystemCompilerInfo
    { mscver :: Int
    , gccIncludeDirectories :: [String]
    }

defaultLanguage :: T.Text
#ifdef CLANG_INLINER
defaultLanguage = "cpp"
#else
defaultLanguage = "simplecpp"
#endif

defaultCaideConf :: FS.FilePath -> Bool -> SystemCompilerInfo -> CF.ConfigParser
defaultCaideConf root useSystemHeaders compiler = forceEither $ flip execStateT CF.emptyCP $ do
    putProp "core" "language" defaultLanguage
    putProp "core" "features" T.empty
    putProp "cpp" "keep_macros"
        ("_WIN32,_WIN64,_MSC_VER,__GNUC__,__clang__,__cplusplus,__STDC_VERSION__,__linux,__linux__" :: T.Text)
    putProp "cpp" "max_consequent_empty_lines" (2 :: Int)
    putProp "cpp" "clang_options" $
        clangOptions root useSystemHeaders compiler & map T.pack & T.intercalate ",\n  "

-- Bundled headers
clangOptions :: FS.FilePath -> Bool -> SystemCompilerInfo -> [String]
clangOptions root False _ =
    [ "-target"
    , "i386-pc-mingw32"
    , "-nostdinc"
    , "-isystem"
    , encodeString $ root </> "include" </> "c++"
    , "-isystem"
    , encodeString $ root </> "include" </> "c++" </> "i686-w64-mingw32"
    , "-isystem"
    , encodeString $ root </> "include" </> "crt"
    , "-I"
    , encodeString $ root </> "cpplib"
    , "-std=c++17"
    , "-fparse-all-comments"
    , "-DONLINE_JUDGE"
    ]

-- Windows with VS headers
clangOptions root True compiler | "mingw" `isPrefixOf` os =
    [ "-target"
    , "i386-pc-windows-msvc"
    , "-fdiagnostics-format=msvc"
    , "-fmsc-version=" ++ show (mscver compiler)
    , "-fparse-all-comments"
    , "-D_CRT_SECURE_NO_WARNINGS"
    , "-DONLINE_JUDGE"
    , "-I"
    , encodeString $ root </> "cpplib"
    ]

-- Linux with system headers
clangOptions root True compiler =
    [ "-target"
    , arch ++ "-" ++ os
    ] ++
    gccHeadersOptions (gccIncludeDirectories compiler) ++
    -- clang builtin headers are still required:
    -- https://clang.llvm.org/docs/LibTooling.html#libtooling-builtin-includes
    [ "-isystem"
    , encodeString $ root </> "include" </> "clang-builtins"
    , "-I"
    , encodeString $ root </> "cpplib"
    , "-fparse-all-comments"
    , "-DONLINE_JUDGE"
    ]

gccHeadersOptions :: [String] -> [String]
gccHeadersOptions [] = []
gccHeadersOptions includeDirectories = ["-nostdinc"] ++
    concat [["-isystem", dir] | dir <- includeDirectories]

forceEither :: Either a c -> c
forceEither = either (error "Left in forceEither") id

defaultCaideState :: CF.ConfigParser
defaultCaideState = forceEither $ flip execStateT CF.emptyCP $
    putProp "core" "problem" T.empty


#ifdef CLANG_INLINER
-- This zip file is prepared in advance in Setup.hs
resourcesZipFile :: BS.ByteString
resourcesZipFile = $(embedFile resourcesZipFilePath)

unpackResources :: FS.FilePath -> IO ()
unpackResources rootDir = do
    let archive = toArchive $ fromStrict resourcesZipFile
        destination = FS.encodeString rootDir
        options = [OptDestination destination]
    extractFilesFromArchive options archive
#endif
