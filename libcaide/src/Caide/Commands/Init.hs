{-# LANGUAGE CPP, OverloadedStrings, NamedFieldPuns, ScopedTypeVariables #-}
#ifdef CLANG_INLINER
{-# LANGUAGE TemplateHaskell #-}
#endif

module Caide.Commands.Init(
      initialize
) where

import Control.Exception (try, IOException)
import Control.Monad (forM_)
import Codec.Archive.Zip (extractFilesFromArchive, toArchive, ZipOption(..))
import qualified Data.ByteString as BS
import Data.ByteString.Lazy (fromStrict)
import Data.Char (isSpace)
import Data.List (dropWhileEnd, isInfixOf)
import Data.Maybe (fromMaybe)
import Data.FileEmbed (embedFile)
import qualified Data.Text as T
import qualified Data.Text.IO.Util as T
import System.Environment (lookupEnv)
import System.Process (readProcessWithExitCode)

import qualified Data.ConfigFile as C
import qualified Filesystem as F
import qualified Filesystem.Path as F
import qualified Filesystem.Path.CurrentOS as F
import Filesystem.Path.CurrentOS ((</>))
import Filesystem.Util (pathToText, writeTextFile)

import Caide.Configuration (SystemCompilerInfo(..), defaultCaideConf, defaultCaideState)
import qualified Caide.Paths as Paths
import Caide.Templates (templates)
import Paths_CaideExt (resourcesZipFilePath) -- autogenerated by Setup.hs


getSystemCompilerInfo :: IO SystemCompilerInfo
getSystemCompilerInfo = do
    [vs12, vs14, vs15] <- mapM lookupEnv ["VS120COMNTOOLS", "VS140COMNTOOLS", "VS150COMNTOOLS"]
    let mscver = case (vs12, vs14, vs15) of
            (_, _, Just _) -> 1900
            (_, Just _, _) -> 1900
            (Just _, _, _) -> 1800
            _              -> 1700
    gcc <- fromMaybe "g++" <$> lookupEnv "CXX"
    -- TODO: More robust subprocess handling (e.g. timeout)
    -- TODO: Set locale
    processResult <- try $ readProcessWithExitCode gcc ["-x", "c++", "-E" ,"-v", "-"] ""
    let gccIncludeDirectories = case processResult of
            Left  (_ex :: IOException)         -> []
            Right (_exitCode, _stdOut, stdErr) -> parseGccOutput stdErr
    return $ SystemCompilerInfo { mscver, gccIncludeDirectories }

parseGccOutput :: String -> [String]
parseGccOutput output = map trim $ filter isDirectory $ takeWhile (not . endOfSearchListLine) $ dropWhile (not . searchStartsHereLine) $ lines output
  where
    trim = dropWhileEnd isSpace . dropWhile isSpace
    isDirectory s = not (null s) && head s == ' '
    endOfSearchListLine s = "End of search list." `isInfixOf` s
    searchStartsHereLine s = "search starts here:" `isInfixOf` s


writeConfigFile :: F.FilePath -> C.ConfigParser -> IO ()
writeConfigFile filePath cp = do
    F.createTree $ F.directory filePath
    writeTextFile filePath . T.pack . C.to_string $ cp


initialize :: F.FilePath -> Bool -> IO ()
initialize curDir useSystemCppHeaders = do
    compiler <- getSystemCompilerInfo
    writeConfigFile (Paths.caideConfFile curDir) $ defaultCaideConf curDir useSystemCppHeaders compiler
    writeConfigFile (Paths.caideStateFile curDir) defaultCaideState
#ifdef CLANG_INLINER
    unpackResources curDir
#endif
    F.createTree $ curDir </> "templates"
    F.createTree $ curDir </> ".caide" </> "templates"
    forM_ templates $ \(fileName, cont) -> do
        writeTextFile (curDir </> "templates" </> fileName) cont
        writeTextFile (curDir </> ".caide" </> "templates" </> fileName) cont
    T.putStrLn . T.concat $ ["Initialized caide directory at ", pathToText curDir]


#ifdef CLANG_INLINER
-- This zip file is prepared in advance in Setup.hs
resourcesZipFile :: BS.ByteString
resourcesZipFile = $(embedFile resourcesZipFilePath)

unpackResources :: F.FilePath -> IO ()
unpackResources rootDir = do
    let archive = toArchive $ fromStrict resourcesZipFile
        destination = F.encodeString rootDir
        options = [OptDestination destination]
    extractFilesFromArchive options archive
#endif

